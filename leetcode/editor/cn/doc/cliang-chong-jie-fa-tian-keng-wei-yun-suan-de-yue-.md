## 解题思路

* `a ^ b`可以得到两数相加不进位的加法结果

* `(a & b) << 1`可以得到两数相加产生的进位

将不进位的加法结果与进位相加，即可得到两数相加的实际结果。需要注意的是：不进位加法结果与进位相加有可能再次造成进位，所以需要迭代处理，直到不再产生新的进位为止。

根据如上思路，可以比较容易地得到递归的解法：

```c++
int getSum(int a, int b) {
	if (!(a & b)) return a ^ b;	// 当进位为0时，返回两数相加不进位的加法结果
    return getSum(a ^ b, ((unsigned int)(a & b)) << 1);	// 否则，递归计算不进位加法结果与进位之和
}
```

也可以采用迭代的解法：

```c++
int getSum(int a, int b) {
	while (b) {
		auto carry = ((unsigned int)(a & b)) << 1;
		a ^= b;
        b = carry;
    }
    return a;
}
```

需要特别注意的是`unsigned int`的用法。

《Primer C++ 第五版》P33：

> 我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。

当`a & b`的结果是负数时，左移就会造成符号位的溢出，所以此处需要转换为`unsigned int`来避免可能出现的左移越界行为。

另外，使用`long long`代替`unsigned int`也是可以的。

